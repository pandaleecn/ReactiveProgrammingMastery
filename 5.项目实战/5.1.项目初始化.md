# é¡¹ç›®åˆå§‹åŒ–

## ä¸€ã€é¡¹ç›®ç»“æ„

### 1.1 ç›®å½•ç»“æ„
```
MyApp/
â”œâ”€â”€ Sources/
â”‚   â”œâ”€â”€ App/
â”‚   â”‚   â”œâ”€â”€ AppDelegate.swift
â”‚   â”‚   â”œâ”€â”€ SceneDelegate.swift
â”‚   â”‚   â””â”€â”€ AppContainer.swift
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ Extensions/
â”‚   â”‚   â”œâ”€â”€ Protocols/
â”‚   â”‚   â””â”€â”€ Utils/
â”‚   â”œâ”€â”€ Data/
â”‚   â”‚   â”œâ”€â”€ Network/
â”‚   â”‚   â”œâ”€â”€ Persistence/
â”‚   â”‚   â””â”€â”€ Repositories/
â”‚   â”œâ”€â”€ Domain/
â”‚   â”‚   â”œâ”€â”€ Entities/
â”‚   â”‚   â”œâ”€â”€ UseCases/
â”‚   â”‚   â””â”€â”€ Interfaces/
â”‚   â”œâ”€â”€ Presentation/
â”‚   â”‚   â”œâ”€â”€ Common/
â”‚   â”‚   â”œâ”€â”€ Scenes/
â”‚   â”‚   â””â”€â”€ Resources/
â”‚   â””â”€â”€ DI/
â”‚       â”œâ”€â”€ Containers/
â”‚       â””â”€â”€ Assemblies/
â”œâ”€â”€ Tests/
â”‚   â”œâ”€â”€ UnitTests/
â”‚   â””â”€â”€ IntegrationTests/
â””â”€â”€ Resources/
    â”œâ”€â”€ Assets.xcassets/
    â””â”€â”€ LaunchScreen.storyboard
```

### 1.2 åŸºç¡€é…ç½®
```swift
// 1. é¡¹ç›®é…ç½®
struct AppConfiguration {
    // ç¯å¢ƒé…ç½®
    enum Environment {
        case development
        case staging
        case production
    }
    
    let environment: Environment
    let apiBaseURL: URL
    let apiKey: String
    
    static func configuration(for environment: Environment) -> AppConfiguration {
        switch environment {
        case .development:
            return AppConfiguration(
                environment: environment,
                apiBaseURL: URL(string: "https://dev-api.example.com")!,
                apiKey: "dev_api_key"
            )
        case .staging:
            return AppConfiguration(
                environment: environment,
                apiBaseURL: URL(string: "https://staging-api.example.com")!,
                apiKey: "staging_api_key"
            )
        case .production:
            return AppConfiguration(
                environment: environment,
                apiBaseURL: URL(string: "https://api.example.com")!,
                apiKey: "production_api_key"
            )
        }
    }
}

// 2. åº”ç”¨å§”æ‰˜
@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
    private var appContainer: AppContainer!
    
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        // åˆå§‹åŒ–åº”ç”¨å®¹å™¨
        let configuration = AppConfiguration.configuration(for: .development)
        appContainer = AppContainer(configuration: configuration)
        
        // è®¾ç½®æ ¹è§†å›¾æ§åˆ¶å™¨
        window = UIWindow(frame: UIScreen.main.bounds)
        window?.rootViewController = appContainer.makeRootViewController()
        window?.makeKeyAndVisible()
        
        return true
    }
}
```

## äºŒã€ä¾èµ–ç®¡ç†

### 2.1 ä¾èµ–å®¹å™¨
```swift
// 1. åº”ç”¨å®¹å™¨
class AppContainer {
    let configuration: AppConfiguration
    private let dependencyContainer: DependencyContainer
    
    init(configuration: AppConfiguration) {
        self.configuration = configuration
        self.dependencyContainer = Container()
        
        setupDependencies()
    }
    
    private func setupDependencies() {
        // æ³¨å†Œæ ¸å¿ƒæœåŠ¡
        registerNetworkServices()
        registerPersistenceServices()
        registerRepositories()
        registerUseCases()
        
        // æ³¨å†Œåœºæ™¯
        registerScenes()
    }
    
    private func registerNetworkServices() {
        let networkConfig = NetworkConfiguration(
            baseURL: configuration.apiBaseURL,
            apiKey: configuration.apiKey
        )
        
        let networkService = NetworkService(configuration: networkConfig)
        dependencyContainer.register(networkService, for: NetworkServiceType.self)
    }
    
    func makeRootViewController() -> UIViewController {
        return dependencyContainer.resolve(RootViewControllerFactory.self)!.makeViewController()
    }
}

// 2. åœºæ™¯å·¥å‚
protocol SceneFactory {
    func makeScene() -> UIViewController
}

class LoginSceneFactory: SceneFactory {
    private let container: DependencyContainer
    
    init(container: DependencyContainer) {
        self.container = container
    }
    
    func makeScene() -> UIViewController {
        let viewModel = LoginViewModel(
            userService: container.resolve(UserServiceType.self)!,
            analyticsService: container.resolve(AnalyticsServiceType.self)!
        )
        return LoginViewController(viewModel: viewModel)
    }
}
```

### 2.2 æ¨¡å—æ³¨å†Œ
```swift
// 1. æ¨¡å—åè®®
protocol AppModule {
    func register(in container: DependencyContainer)
}

// 2. åŠŸèƒ½æ¨¡å—
class UserModule: AppModule {
    func register(in container: DependencyContainer) {
        // æ³¨å†ŒæœåŠ¡
        container.register(UserService(), for: UserServiceType.self)
        container.register(UserRepository(), for: UserRepositoryType.self)
        
        // æ³¨å†Œç”¨ä¾‹
        container.register(
            LoginUseCase(
                repository: container.resolve(UserRepositoryType.self)!
            ),
            for: LoginUseCaseType.self
        )
        
        // æ³¨å†Œåœºæ™¯å·¥å‚
        container.register(
            LoginSceneFactory(container: container),
            for: LoginSceneFactoryType.self
        )
    }
}

// 3. æ¨¡å—æ³¨å†Œå™¨
class ModuleRegistrar {
    private let container: DependencyContainer
    private let modules: [AppModule]
    
    init(container: DependencyContainer, modules: [AppModule]) {
        self.container = container
        self.modules = modules
    }
    
    func registerAllModules() {
        modules.forEach { module in
            module.register(in: container)
        }
    }
}
```

## ä¸‰ã€åŸºç¡€è®¾æ–½

### 3.1 ç½‘ç»œå±‚
```swift
// 1. ç½‘ç»œé…ç½®
struct NetworkConfiguration {
    let baseURL: URL
    let apiKey: String
    var headers: [String: String] {
        return [
            "Authorization": "Bearer \(apiKey)",
            "Content-Type": "application/json"
        ]
    }
}

// 2. ç½‘ç»œæœåŠ¡
class NetworkService: NetworkServiceType {
    private let configuration: NetworkConfiguration
    private let session: URLSession
    
    init(configuration: NetworkConfiguration,
         session: URLSession = .shared) {
        self.configuration = configuration
        self.session = session
    }
    
    func request<T: Decodable>(_ endpoint: Endpoint) -> Observable<T> {
        return Observable.create { [weak self] observer in
            guard let self = self else {
                observer.onCompleted()
                return Disposables.create()
            }
            
            let request = self.buildRequest(from: endpoint)
            let task = self.session.dataTask(with: request) { data, response, error in
                if let error = error {
                    observer.onError(error)
                    return
                }
                
                guard let data = data else {
                    observer.onError(NetworkError.noData)
                    return
                }
                
                do {
                    let decoded = try JSONDecoder().decode(T.self, from: data)
                    observer.onNext(decoded)
                    observer.onCompleted()
                } catch {
                    observer.onError(error)
                }
            }
            
            task.resume()
            
            return Disposables.create {
                task.cancel()
            }
        }
    }
}
```

### 3.2 æŒä¹…åŒ–å±‚
```swift
// 1. å­˜å‚¨é…ç½®
struct StorageConfiguration {
    let databaseName: String
    let schemaVersion: UInt64
}

// 2. å­˜å‚¨æœåŠ¡
class StorageService: StorageServiceType {
    private let configuration: StorageConfiguration
    private let realm: Realm
    
    init(configuration: StorageConfiguration) throws {
        self.configuration = configuration
        
        let config = Realm.Configuration(
            schemaVersion: configuration.schemaVersion,
            migrationBlock: { migration, oldSchemaVersion in
                // å¤„ç†æ•°æ®åº“è¿ç§»
            }
        )
        
        self.realm = try Realm(configuration: config)
    }
    
    func save<T: Object>(_ object: T) -> Observable<Void> {
        return Observable.create { [weak self] observer in
            guard let self = self else {
                observer.onCompleted()
                return Disposables.create()
            }
            
            do {
                try self.realm.write {
                    self.realm.add(object, update: .modified)
                }
                observer.onNext(())
                observer.onCompleted()
            } catch {
                observer.onError(error)
            }
            
            return Disposables.create()
        }
    }
}
```

## å››ã€å·¥å…·ç±»

### 4.1 æ—¥å¿—å·¥å…·
```swift
// 1. æ—¥å¿—çº§åˆ«
enum LogLevel: String {
    case debug = "ğŸ“"
    case info = "â„¹ï¸"
    case warning = "âš ï¸"
    case error = "âŒ"
}

// 2. æ—¥å¿—æœåŠ¡
class Logger {
    static let shared = Logger()
    private let dateFormatter: DateFormatter
    
    private init() {
        dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss.SSS"
    }
    
    func log(
        _ message: String,
        level: LogLevel = .info,
        file: String = #file,
        function: String = #function,
        line: Int = #line
    ) {
        #if DEBUG
        let timestamp = dateFormatter.string(from: Date())
        let filename = (file as NSString).lastPathComponent
        let log = "\(timestamp) \(level.rawValue) [\(filename):\(line)] \(function) - \(message)"
        print(log)
        #endif
    }
}

// 3. ä½¿ç”¨ç¤ºä¾‹
extension Logger {
    static func trackNetworkRequest(_ request: URLRequest) {
        shared.log("ğŸ“¡ Request: \(request.url?.absoluteString ?? "")", level: .debug)
        if let headers = request.allHTTPHeaderFields {
            shared.log("Headers: \(headers)", level: .debug)
        }
        if let body = request.httpBody {
            shared.log("Body: \(String(data: body, encoding: .utf8) ?? "")", level: .debug)
        }
    }
}
```

### 4.2 åˆ†æå·¥å…·
```swift
// 1. åˆ†æäº‹ä»¶
struct AnalyticsEvent {
    let name: String
    let parameters: [String: Any]?
    let timestamp: Date
}

// 2. åˆ†ææœåŠ¡
class Analytics {
    static let shared = Analytics()
    private let eventSubject = PublishSubject<AnalyticsEvent>()
    private let disposeBag = DisposeBag()
    
    private init() {
        setupEventTracking()
    }
    
    private func setupEventTracking() {
        eventSubject
            .subscribe(onNext: { event in
                // å‘é€åˆ°åˆ†ææœåŠ¡
                self.send(event)
            })
            .disposed(by: disposeBag)
    }
    
    func track(
        eventName: String,
        parameters: [String: Any]? = nil
    ) {
        let event = AnalyticsEvent(
            name: eventName,
            parameters: parameters,
            timestamp: Date()
        )
        eventSubject.onNext(event)
    }
}
```

## äº”ã€å¯åŠ¨æµç¨‹

### 5.1 å¯åŠ¨ç®¡ç†
```swift
// 1. å¯åŠ¨ä»»åŠ¡
protocol LaunchTask {
    var priority: Int { get }
    func execute() -> Observable<Void>
}

// 2. å¯åŠ¨ç®¡ç†å™¨
class LaunchManager {
    private let tasks: [LaunchTask]
    private let disposeBag = DisposeBag()
    
    init(tasks: [LaunchTask]) {
        self.tasks = tasks.sorted { $0.priority < $1.priority }
    }
    
    func launch() -> Observable<Void> {
        return Observable.concat(
            tasks.map { $0.execute() }
        )
    }
}

// 3. å…·ä½“ä»»åŠ¡
class DatabaseInitTask: LaunchTask {
    let priority = 1
    
    func execute() -> Observable<Void> {
        return Observable.create { observer in
            // åˆå§‹åŒ–æ•°æ®åº“
            observer.onNext(())
            observer.onCompleted()
            return Disposables.create()
        }
    }
}

class NetworkInitTask: LaunchTask {
    let priority = 2
    
    func execute() -> Observable<Void> {
        return Observable.create { observer in
            // åˆå§‹åŒ–ç½‘ç»œæœåŠ¡
            observer.onNext(())
            observer.onCompleted()
            return Disposables.create()
        }
    }
}
```

### 5.2 å¯åŠ¨æµç¨‹
```swift
extension AppDelegate {
    func setupLaunchProcess() {
        // 1. åˆ›å»ºå¯åŠ¨ä»»åŠ¡
        let tasks: [LaunchTask] = [
            DatabaseInitTask(),
            NetworkInitTask(),
            UserSessionTask(),
            AnalyticsTask()
        ]
        
        // 2. åˆ›å»ºå¯åŠ¨ç®¡ç†å™¨
        let launchManager = LaunchManager(tasks: tasks)
        
        // 3. æ‰§è¡Œå¯åŠ¨æµç¨‹
        launchManager.launch()
            .subscribe(
                onNext: { [weak self] in
                    self?.handleLaunchSuccess()
                },
                onError: { [weak self] error in
                    self?.handleLaunchError(error)
                }
            )
            .disposed(by: disposeBag)
    }
    
    private func handleLaunchSuccess() {
        // æ˜¾ç¤ºä¸»ç•Œé¢
        window?.rootViewController = appContainer.makeRootViewController()
        window?.makeKeyAndVisible()
    }
    
    private func handleLaunchError(_ error: Error) {
        // æ˜¾ç¤ºé”™è¯¯ç•Œé¢
        Logger.shared.log("Launch failed: \(error)", level: .error)
        window?.rootViewController = ErrorViewController(error: error)
        window?.makeKeyAndVisible()
    }
}
```

## ä¸‹ä¸€æ­¥
- [åŠŸèƒ½æ¨¡å—å¼€å‘](5.2.åŠŸèƒ½æ¨¡å—å¼€å‘.md)
- [ç•Œé¢å¼€å‘](5.3.ç•Œé¢å¼€å‘.md)
- [æµ‹è¯•ä¸éƒ¨ç½²](5.4.æµ‹è¯•ä¸éƒ¨ç½².md) 